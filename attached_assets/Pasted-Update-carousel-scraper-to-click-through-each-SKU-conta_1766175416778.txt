Update carousel scraper to click through each SKU container and extract detailed product information.

IMPORTANT DISCOVERY:
Company websites (ukrainka.ua, etc.) have this structure:
1. Carousel shows product containers (cards/thumbnails)
2. Each container is CLICKABLE
3. Clicking opens detail page/modal with full info: name, size, ABV, features, description
4. Need to click EACH product to get complete details

CURRENT PROBLEM:
Carousel scraper only reads visible carousel content, doesn't click through to product details.

SOLUTION:
Update carousel_scraper.py to click each product container and extract detailed info.

UPDATE backend/services/carousel_scraper.py:

Replace scrape_product_carousel function with click-through version:
```python
async def scrape_product_carousel(url: str, brand_name: str = None) -> dict:
    """
    Scrape product details by clicking through carousel items.
    Handles sites where each carousel item links to detailed product page.
    """
    print(f"üîç Starting click-through carousel scraper for {url}")
    
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        context = await browser.new_context()
        page = await context.new_page()
        
        try:
            # Navigate
            await page.goto(url, wait_until="networkidle", timeout=45000)
            print("‚úÖ Page loaded, waiting for carousel...")
            await page.wait_for_timeout(4000)
            
            # Find all product containers/cards in carousel
            product_containers = []
            container_selectors = [
                '.product', '.product-card', '.product-item', '.item',
                '.swiper-slide', '.slick-slide', '.carousel-item',
                '[class*="product"]', '[class*="item"]', '[class*="card"]',
                'a[href*="product"]', 'a[href*="#"]'
            ]
            
            for selector in container_selectors:
                containers = await page.query_selector_all(selector)
                if containers and len(containers) > 1:
                    print(f"‚úÖ Found {len(containers)} containers with: {selector}")
                    product_containers = containers
                    break
            
            if not product_containers:
                print("‚ö†Ô∏è No product containers found, falling back to text extraction")
                raw_text = await page.evaluate('() => document.body.innerText')
                await browser.close()
                return {'products': [], 'raw_text': raw_text, 'carousel_detected': False}
            
            print(f"üì¶ Found {len(product_containers)} product containers to click through")
            
            products = []
            
            # Click through each container
            for idx in range(min(len(product_containers), 20)):  # Limit to 20 products
                try:
                    print(f"  üñ±Ô∏è  Clicking product {idx + 1}/{len(product_containers)}...")
                    
                    # Re-query containers (page may have changed)
                    containers = await page.query_selector_all(container_selectors[0])
                    if idx >= len(containers):
                        break
                    
                    container = containers[idx]
                    
                    # Get href if it's a link
                    href = await container.get_attribute('href')
                    
                    # Click the container
                    await container.click()
                    await page.wait_for_timeout(2000)  # Wait for modal/page
                    
                    # Extract detailed product info from modal/new page
                    product_info = await page.evaluate('''() => {
                        const getText = (selectors) => {
                            if (typeof selectors === 'string') selectors = [selectors];
                            for (let selector of selectors) {
                                const elements = document.querySelectorAll(selector);
                                for (let el of elements) {
                                    if (el && el.innerText && el.innerText.trim()) {
                                        return el.innerText.trim();
                                    }
                                }
                            }
                            return '';
                        };
                        
                        // Extract from modal or detail page
                        const modal = document.querySelector('.modal, [role="dialog"], .popup, [class*="modal"], [class*="popup"]');
                        const context = modal || document.body;
                        
                        return {
                            name: getText([
                                'h1', 'h2', 'h3',
                                '.product-name', '.product-title', '.name', '.title',
                                '[class*="product-name"]', '[class*="title"]'
                            ]),
                            size: getText([
                                '.size', '.volume', '.capacity', '.ml', '.liters',
                                '[class*="size"]', '[class*="volume"]', '[class*="capacity"]',
                                'span:has-text("–ª")', 'span:has-text("ml")', 'div:has-text("–æ–± º—î–º")'
                            ]),
                            abv: getText([
                                '.abv', '.alcohol', '.strength', '.percent',
                                '[class*="abv"]', '[class*="alcohol"]', '[class*="strength"]',
                                'span:has-text("%")', 'div:has-text("–º—ñ—Ü–Ω—ñ—Å—Ç—å")'
                            ]),
                            price: getText([
                                '.price', '[class*="price"]', '[data-price]',
                                'span:has-text("‚Ç¥")', 'div:has-text("–≥—Ä–Ω")'
                            ]),
                            description: getText([
                                '.description', '.desc', '.details', '.info',
                                '[class*="description"]', '[class*="details"]',
                                'p', '.text'
                            ]),
                            features: getText([
                                '.features', '.characteristics', '.specs',
                                '[class*="features"]', '[class*="characteristics"]'
                            ]),
                            // Get all visible text as fallback
                            allText: (modal || context).innerText || ''
                        };
                    }''')
                    
                    # Clean and validate
                    if (product_info.get('name') or 
                        product_info.get('size') or 
                        len(product_info.get('allText', '')) > 50):
                        
                        cleaned = {
                            'name': product_info.get('name', '').strip(),
                            'size': product_info.get('size', '').strip(),
                            'abv': product_info.get('abv', '').strip(),
                            'price': product_info.get('price', '').strip(),
                            'description': product_info.get('description', '').strip()[:300],
                            'features': product_info.get('features', '').strip()[:300],
                            'allText': product_info.get('allText', '').strip()[:500]
                        }
                        
                        products.append(cleaned)
                        print(f"    ‚úÖ Extracted: {cleaned['name'][:50] or 'Product ' + str(idx+1)}")
                    
                    # Close modal or go back
                    # Try to find close button
                    close_selectors = [
                        'button[class*="close"]', '[data-dismiss]', '.close',
                        'button:has-text("√ó")', 'button:has-text("Close")',
                        '[aria-label*="close"]', '[aria-label*="Close"]'
                    ]
                    
                    closed = False
                    for close_sel in close_selectors:
                        close_btn = await page.query_selector(close_sel)
                        if close_btn:
                            try:
                                await close_btn.click()
                                await page.wait_for_timeout(500)
                                closed = True
                                break
                            except:
                                pass
                    
                    # If no close button, try ESC key or back navigation
                    if not closed:
                        if href and href.startswith('#'):
                            # Hash link, try ESC
                            await page.keyboard.press('Escape')
                            await page.wait_for_timeout(500)
                        else:
                            # Full page navigation, go back
                            await page.go_back()
                            await page.wait_for_timeout(1500)
                
                except Exception as e:
                    print(f"    ‚ö†Ô∏è Error processing product {idx + 1}: {e}")
                    # Try to recover - go back to main page
                    try:
                        await page.goto(url, wait_until="networkidle", timeout=15000)
                        await page.wait_for_timeout(2000)
                    except:
                        pass
                    continue
            
            # Get page text as fallback
            await page.goto(url, wait_until="networkidle")
            raw_text = await page.evaluate('() => document.body.innerText')
            
            await browser.close()
            
            print(f"‚úÖ Click-through complete: {len(products)} products extracted")
            
            return {
                'products': products,
                'raw_text': raw_text,
                'carousel_detected': True,
                'product_count': len(products)
            }
            
        except Exception as e:
            await browser.close()
            print(f"‚ùå Click-through scraping error: {e}")
            return {
                'products': [],
                'raw_text': '',
                'error': str(e),
                'carousel_detected': False
            }
```

IMPROVEMENTS:
1. Finds all product containers in carousel
2. Clicks EACH container (up to 20)
3. Waits for modal/detail page to load
4. Extracts complete product info (name, size, ABV, description, features)
5. Closes modal or navigates back
6. Repeats for all products

BENEFITS:
- Gets detailed SKU information, not just carousel thumbnails
- Handles both modals and full page navigation
- Extracts features, descriptions, specs
- Maya can answer detailed product questions

TEST:
curl -X POST http://localhost:8000/api/chat -H "Content-Type: application/json" -d '{"message": "–í–∏–≤—á–∏ https://ukrainka.ua/#more"}'

Should extract detailed info for each UKRAINKA product by clicking through carousel.

Then test:
curl -X POST http://localhost:8000/api/chat -H "Content-Type: application/json" -d '{"message": "Maya, —è–∫—ñ –ø—Ä–æ–¥—É–∫—Ç–∏ —î –≤ –ª—ñ–Ω—ñ–π—Ü—ñ UKRAINKA?"}'

Should list products with sizes, ABV, descriptions, features.

Deploy after tests pass.