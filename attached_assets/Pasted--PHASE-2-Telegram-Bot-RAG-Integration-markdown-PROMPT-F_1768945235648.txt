ðŸŽ¯ PHASE 2: Telegram Bot RAG Integration
markdown# PROMPT FOR REPLIT AGENT:

## TASK: Integrate HR RAG System with Telegram Bot

### Current State
- Maya bot handles brand questions (product-facing)
- HR RAG system is built and working (API functional)
- Need to connect employees to HR knowledge via Telegram

### Requirements

1. **Update Bot Handlers for HR Queries**

File: `app/bot/handlers.py`
```python
from app.services.hr_rag_service import HRRagService
import httpx

hr_rag = HRRagService()

# Add after existing handlers

@router.message(F.text & ~F.command() & F.from_user)
async def hr_question_handler(message: Message, state: FSMContext):
    """
    Handle employee HR questions
    Flow:
    1. Check if preset answer available (fast)
    2. If not, use RAG semantic search
    3. Return answer with sources
    """
    
    user_id = message.from_user.id
    query = message.text.strip()
    
    # Show typing indicator
    await message.bot.send_chat_action(
        chat_id=message.chat.id,
        action="typing"
    )
    
    try:
        # Call HR API
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{settings.API_BASE_URL}/api/hr/answer",
                json={
                    "query": query,
                    "user_id": user_id
                },
                timeout=15.0
            )
            
            if response.status_code != 200:
                await message.answer(
                    "âŒ Ð’Ð¸Ð±Ð°Ñ‡Ñ‚Ðµ, Ð²Ð¸Ð½Ð¸ÐºÐ»Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ°. Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ñ‰Ðµ Ñ€Ð°Ð· Ð°Ð±Ð¾ Ð·Ð²ÐµÑ€Ð½Ñ–Ñ‚ÑŒÑÑ Ð´Ð¾ HR."
                )
                return
            
            data = response.json()
        
        # Send answer
        answer_text = data['answer']
        sources = data.get('sources', [])
        is_preset = data.get('source') == 'preset'
        
        # Format answer
        if is_preset:
            # Preset answers are already formatted
            await message.answer(
                answer_text,
                parse_mode="Markdown",
                reply_markup=create_main_menu_keyboard()
            )
        else:
            # RAG-generated answer - add context
            full_response = f"{answer_text}\n\n"
            
            if sources:
                full_response += "ðŸ“š **Ð”Ð¶ÐµÑ€ÐµÐ»Ð°:**\n"
                for idx, source in enumerate(sources[:3], 1):
                    full_response += f"{idx}. {source['title']}\n"
            
            await message.answer(
                full_response,
                parse_mode="Markdown",
                reply_markup=create_feedback_keyboard(sources)
            )
        
        # Log query for analytics
        await log_hr_query(user_id, query, is_preset, sources)
        
    except httpx.TimeoutException:
        await message.answer(
            "â±ï¸ Ð—Ð°Ð¿Ð¸Ñ‚ Ð¾Ð±Ñ€Ð¾Ð±Ð»ÑÑ”Ñ‚ÑŒÑÑ Ð´Ð¾Ð²Ð³Ð¾. Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿ÐµÑ€ÐµÑ„Ð¾Ñ€Ð¼ÑƒÐ»ÑŽÐ²Ð°Ñ‚Ð¸ Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ Ð°Ð±Ð¾ Ð·Ð²ÐµÑ€Ð½Ñ–Ñ‚ÑŒÑÑ Ð´Ð¾ HR."
        )
    except Exception as e:
        logger.error(f"HR query error: {e}")
        await message.answer(
            "âŒ ÐÐµ Ð²Ð´Ð°Ð»Ð¾ÑÑ Ð¾Ð±Ñ€Ð¾Ð±Ð¸Ñ‚Ð¸ Ð·Ð°Ð¿Ð¸Ñ‚. Ð—Ð²ÐµÑ€Ð½Ñ–Ñ‚ÑŒÑÑ Ð´Ð¾ HR Ð´ÐµÐ¿Ð°Ñ€Ñ‚Ð°Ð¼ÐµÐ½Ñ‚Ñƒ."
        )

async def log_hr_query(user_id: int, query: str, is_preset: bool, sources: list):
    """Log query for analytics"""
    try:
        async with httpx.AsyncClient() as client:
            await client.post(
                f"{settings.API_BASE_URL}/api/hr/log-query",
                json={
                    "user_id": user_id,
                    "query": query,
                    "preset_matched": is_preset,
                    "content_ids": [s['content_id'] for s in sources] if sources else []
                }
            )
    except:
        pass  # Don't fail if logging fails
```

2. **Create Interactive Keyboards**

File: `app/bot/keyboards.py`
```python
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton

def create_main_menu_keyboard() -> InlineKeyboardMarkup:
    """Main HR menu with 6 primary categories"""
    buttons = [
        [
            InlineKeyboardButton(
                text="ðŸ“– ÐŸÑ€Ð¾ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ñ–ÑŽ", 
                callback_data="menu:about"
            ),
            InlineKeyboardButton(
                text="ðŸš€ ÐÐ¾Ð²Ð°Ñ‡ÐºÐ°Ð¼", 
                callback_data="menu:onboarding"
            )
        ],
        [
            InlineKeyboardButton(
                text="ðŸ’¼ Ð Ð¾Ð±Ð¾Ñ‡Ñ– Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ", 
                callback_data="menu:work"
            ),
            InlineKeyboardButton(
                text="ðŸ’° Ð—Ð°Ñ€Ð¿Ð»Ð°Ñ‚Ð°", 
                callback_data="menu:salary"
            )
        ],
        [
            InlineKeyboardButton(
                text="ðŸ”§ Ð¢ÐµÑ…. Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ°", 
                callback_data="menu:tech"
            ),
            InlineKeyboardButton(
                text="ðŸ“ž ÐšÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¸", 
                callback_data="menu:contacts"
            )
        ],
        [
            InlineKeyboardButton(
                text="â“ Ð—Ð°Ð´Ð°Ñ‚Ð¸ Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ", 
                switch_inline_query_current_chat=""
            )
        ]
    ]
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def create_feedback_keyboard(sources: list = None) -> InlineKeyboardMarkup:
    """Keyboard with feedback and navigation"""
    buttons = [
        [
            InlineKeyboardButton(text="ðŸ‘ ÐšÐ¾Ñ€Ð¸ÑÐ½Ð¾", callback_data="feedback:helpful"),
            InlineKeyboardButton(text="ðŸ‘Ž ÐÐµ Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ð»Ð¾", callback_data="feedback:not_helpful")
        ]
    ]
    
    # Add source buttons if available
    if sources:
        for idx, source in enumerate(sources[:2], 1):  # Max 2 sources as buttons
            buttons.append([
                InlineKeyboardButton(
                    text=f"ðŸ“„ {source['title'][:30]}...",
                    callback_data=f"source:{source['content_id']}"
                )
            ])
    
    buttons.append([
        InlineKeyboardButton(text="ðŸ  Ð“Ð¾Ð»Ð¾Ð²Ð½Ðµ Ð¼ÐµÐ½ÑŽ", callback_data="menu:main")
    ])
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def create_category_keyboard(category: str) -> InlineKeyboardMarkup:
    """Create submenu for specific category"""
    
    # Define submenus
    SUBMENUS = {
        'onboarding': [
            ('ðŸ“‹ Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð¸ Ð´Ð»Ñ Ð¿Ñ€Ð°Ñ†ÐµÐ²Ð»Ð°ÑˆÑ‚ÑƒÐ²Ð°Ð½Ð½Ñ', 'content:q1_documents'),
            ('ðŸ” ÐšÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½Ð¸Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿', 'content:q2_account_creation'),
            ('ðŸ“± ÐŸÐµÑ€ÑˆÑ– ÐºÑ€Ð¾ÐºÐ¸', 'submenu:first_steps'),
            ('ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'menu:main')
        ],
        'salary': [
            ('ðŸ’µ Ð¡Ñ‚Ñ€Ð¾ÐºÐ¸ Ð²Ð¸Ð¿Ð»Ð°Ñ‚Ð¸', 'content:q13_salary_dates'),
            ('â“ ÐŸÐ¸Ñ‚Ð°Ð½Ð½Ñ Ð¿Ñ€Ð¾ Ð½Ð°Ñ€Ð°Ñ…ÑƒÐ²Ð°Ð½Ð½Ñ', 'content:q14_salary_questions'),
            ('ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'menu:main')
        ],
        'work': [
            ('ðŸ–ï¸ Ð’Ñ–Ð´Ð¿ÑƒÑÑ‚ÐºÐ¸', 'submenu:vacation'),
            ('ðŸ¥ Ð›Ñ–ÐºÐ°Ñ€Ð½ÑÐ½Ñ–', 'content:q10_sick_leave'),
            ('ðŸ  Ð’Ñ–Ð´Ð´Ð°Ð»ÐµÐ½Ð° Ñ€Ð¾Ð±Ð¾Ñ‚Ð°', 'content:q11_remote_work'),
            ('âœˆï¸ Ð’Ñ–Ð´Ñ€ÑÐ´Ð¶ÐµÐ½Ð½Ñ', 'content:q12_business_trip'),
            ('ðŸ¤ Ð’Ð¸Ñ€Ñ–ÑˆÐµÐ½Ð½Ñ ÐºÐ¾Ð½Ñ„Ð»Ñ–ÐºÑ‚Ñ–Ð²', 'content:q20_conflict'),
            ('ðŸ“¤ Ð—Ð²Ñ–Ð»ÑŒÐ½ÐµÐ½Ð½Ñ', 'content:q26_resignation'),
            ('ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'menu:main')
        ],
        'tech': [
            ('ðŸ’» ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ð¸ Ð· ÐŸÐš', 'content:q17_pc_issues'),
            ('ðŸ“± ÐšÐŸÐš / ÐŸÐ»Ð°Ð½ÑˆÐµÑ‚', 'content:q15_mobile_device'),
            ('ðŸ“„ Ð¡Ð•Ð” Ð‘Ð»Ñ–Ñ†', 'submenu:sed_blitz'),
            ('ðŸŒ Ð’Ñ–Ð´Ð´Ð°Ð»ÐµÐ½Ð¸Ð¹ Ñ€Ð¾Ð±Ð¾Ñ‡Ð¸Ð¹ ÑÑ‚Ñ–Ð»', 'content:q18_remote_setup'),
            ('ðŸ› ï¸ ÐšÐ°Ð½Ñ†Ñ‚Ð¾Ð²Ð°Ñ€Ð¸ Ñ‚Ð° Ð¼ÐµÐ±Ð»Ñ–', 'submenu:supplies'),
            ('ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'menu:main')
        ],
        'about': [
            ('ðŸŽ¬ Ð—Ð°Ð³Ð°Ð»ÑŒÐ½Ð° Ñ–Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ', 'content:section_1_general'),
            ('ðŸ’Ž Ð¦Ñ–Ð½Ð½Ð¾ÑÑ‚Ñ– ÐºÐ¾Ð¼Ð¿Ð°Ð½Ñ–Ñ—', 'content:section_2_values'),
            ('ðŸ“œ Ð†ÑÑ‚Ð¾Ñ€Ñ–Ñ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ñ–Ñ—', 'content:section_3_history'),
            ('ðŸ—ï¸ Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° ÐºÐ¾Ð¼Ð¿Ð°Ð½Ñ–Ñ—', 'content:section_4_structure'),
            ('ðŸ’ª ÐÐ°ÑˆÑ– Ð¿ÐµÑ€ÐµÐ²Ð°Ð³Ð¸', 'content:section_4_advantages'),
            ('ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'menu:main')
        ],
        'contacts': [
            ('ðŸ“‹ Ð¡Ð¿Ð¸ÑÐ¾Ðº ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ñ–Ð²', 'content:appendix_22'),
            ('ðŸ”™ ÐÐ°Ð·Ð°Ð´', 'menu:main')
        ]
    }
    
    items = SUBMENUS.get(category, [])
    buttons = [[InlineKeyboardButton(text=text, callback_data=data)] for text, data in items]
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)
```

3. **Add Callback Handlers for Menu Navigation**
```python
@router.callback_query(F.data.startswith("menu:"))
async def menu_handler(callback: CallbackQuery):
    """Handle menu navigation"""
    await callback.answer()
    
    menu_id = callback.data.split(":")[1]
    
    if menu_id == "main":
        await callback.message.edit_text(
            "ðŸ¢ **Maya HR Assistant**\n\n"
            "ÐžÐ±ÐµÑ€Ñ–Ñ‚ÑŒ Ñ€Ð¾Ð·Ð´Ñ–Ð» Ð°Ð±Ð¾ Ð½Ð°Ð¿Ð¸ÑˆÑ–Ñ‚ÑŒ ÑÐ²Ð¾Ñ” Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ:",
            reply_markup=create_main_menu_keyboard(),
            parse_mode="Markdown"
        )
    
    elif menu_id in ['about', 'onboarding', 'work', 'salary', 'tech', 'contacts']:
        titles = {
            'about': 'ðŸ“– ÐŸÑ€Ð¾ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ñ–ÑŽ',
            'onboarding': 'ðŸš€ Ð†Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ Ð´Ð»Ñ Ð½Ð¾Ð²Ð°Ñ‡ÐºÑ–Ð²',
            'work': 'ðŸ’¼ Ð Ð¾Ð±Ð¾Ñ‡Ñ– Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ',
            'salary': 'ðŸ’° Ð—Ð°Ñ€Ð¿Ð»Ð°Ñ‚Ð° Ñ‚Ð° Ð²Ñ–Ð´Ð¿ÑƒÑÑ‚ÐºÐ¸',
            'tech': 'ðŸ”§ Ð¢ÐµÑ…Ð½Ñ–Ñ‡Ð½Ð° Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ°',
            'contacts': 'ðŸ“ž ÐšÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¸ ÑÐ¿ÐµÑ†Ñ–Ð°Ð»Ñ–ÑÑ‚Ñ–Ð²'
        }
        
        await callback.message.edit_text(
            f"{titles[menu_id]}\n\nÐžÐ±ÐµÑ€Ñ–Ñ‚ÑŒ Ð¿Ñ–Ð´Ñ€Ð¾Ð·Ð´Ñ–Ð»:",
            reply_markup=create_category_keyboard(menu_id),
            parse_mode="Markdown"
        )

@router.callback_query(F.data.startswith("content:"))
async def content_handler(callback: CallbackQuery):
    """Show specific content"""
    await callback.answer()
    
    content_id = callback.data.split(":")[1]
    
    # Fetch content from API
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{settings.API_BASE_URL}/api/hr/content/{content_id}"
            )
            
            if response.status_code == 200:
                data = response.json()
                
                # Format content
                title = data.get('title', '')
                content_type = data.get('content_type', 'text')
                content = data.get('content', '')
                
                if content_type == 'video' and data.get('video_url'):
                    # Send video
                    await callback.message.answer_video(
                        video=data['video_url'],
                        caption=f"ðŸŽ¬ **{title}**",
                        parse_mode="Markdown"
                    )
                    
                    # Fallback text option
                    await callback.message.answer(
                        "ÐÐ±Ð¾ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð¹Ñ‚Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ñƒ Ð²ÐµÑ€ÑÑ–ÑŽ:",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[[
                            InlineKeyboardButton(
                                text="ðŸ“„ Ð¢ÐµÐºÑÑ‚Ð¾Ð²Ð° Ð²ÐµÑ€ÑÑ–Ñ",
                                callback_data=f"text:{content_id}"
                            )
                        ]])
                    )
                
                elif content_type == 'table':
                    # Format table for Telegram
                    table_data = data.get('metadata', {}).get('table_data', {})
                    formatted_table = format_table_for_telegram(table_data)
                    
                    await callback.message.edit_text(
                        f"**{title}**\n\n{formatted_table}",
                        parse_mode="Markdown",
                        reply_markup=create_main_menu_keyboard()
                    )
                
                else:
                    # Regular text content
                    # Split if too long (Telegram limit: 4096 chars)
                    if len(content) > 3800:
                        chunks = split_long_message(content, 3800)
                        for idx, chunk in enumerate(chunks):
                            if idx == 0:
                                await callback.message.edit_text(
                                    f"**{title}**\n\n{chunk}",
                                    parse_mode="Markdown"
                                )
                            else:
                                await callback.message.answer(
                                    chunk,
                                    parse_mode="Markdown"
                                )
                        
                        # Add navigation at the end
                        await callback.message.answer(
                            "â”€â”€â”€â”€â”€â”€â”€â”€â”€",
                            reply_markup=create_main_menu_keyboard()
                        )
                    else:
                        await callback.message.edit_text(
                            f"**{title}**\n\n{content}",
                            parse_mode="Markdown",
                            reply_markup=create_main_menu_keyboard()
                        )
            
            else:
                await callback.message.edit_text(
                    "âŒ ÐšÐ¾Ð½Ñ‚ÐµÐ½Ñ‚ Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾. Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ñ–Ð½ÑˆÐ¸Ð¹ Ñ€Ð¾Ð·Ð´Ñ–Ð».",
                    reply_markup=create_main_menu_keyboard()
                )
    
    except Exception as e:
        logger.error(f"Content fetch error: {e}")
        await callback.message.edit_text(
            "âŒ ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ. Ð¡Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ñ–Ð·Ð½Ñ–ÑˆÐµ.",
            reply_markup=create_main_menu_keyboard()
        )

def format_table_for_telegram(table_data: dict) -> str:
    """Format table data for Telegram display"""
    if not table_data:
        return "Ð¢Ð°Ð±Ð»Ð¸Ñ†Ñ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°"
    
    headers = table_data.get('headers', [])
    rows = table_data.get('rows', [])
    
    # Use monospace font for alignment
    output = "```\n"
    
    # Headers
    header_line = " | ".join(h[:15] for h in headers)  # Truncate long headers
    output += header_line + "\n"
    output += "-" * len(header_line) + "\n"
    
    # Rows (limit to first 20 for readability)
    for row in rows[:20]:
        row_line = " | ".join(str(cell)[:15] for cell in row)
        output += row_line + "\n"
    
    if len(rows) > 20:
        output += f"\n...Ñ‚Ð° Ñ‰Ðµ {len(rows) - 20} Ñ€ÑÐ´ÐºÑ–Ð²\n"
    
    output += "```"
    
    return output

def split_long_message(text: str, max_length: int = 3800) -> list:
    """Split long message into chunks"""
    if len(text) <= max_length:
        return [text]
    
    chunks = []
    current_chunk = ""
    
    for paragraph in text.split('\n\n'):
        if len(current_chunk) + len(paragraph) + 2 <= max_length:
            current_chunk += paragraph + "\n\n"
        else:
            if current_chunk:
                chunks.append(current_chunk.strip())
            current_chunk = paragraph + "\n\n"
    
    if current_chunk:
        chunks.append(current_chunk.strip())
    
    return chunks

@router.callback_query(F.data.startswith("feedback:"))
async def feedback_handler(callback: CallbackQuery):
    """Handle user feedback"""
    await callback.answer("Ð”ÑÐºÑƒÑ”Ð¼Ð¾ Ð·Ð° Ð²Ñ–Ð´Ð³ÑƒÐº!")
    
    feedback_type = callback.data.split(":")[1]
    
    # Log feedback (implement as needed)
    # Could update database, send to analytics, etc.
    
    if feedback_type == "not_helpful":
        await callback.message.answer(
            "Ð’Ð¸Ð±Ð°Ñ‡Ñ‚Ðµ, Ñ‰Ð¾ Ð½Ðµ Ð·Ð¼Ð¾Ð³Ð»Ð° Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ñ‚Ð¸. "
            "Ð’Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ:\n"
            "â€¢ ÐŸÐµÑ€ÐµÑ„Ð¾Ñ€Ð¼ÑƒÐ»ÑŽÐ²Ð°Ñ‚Ð¸ Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ\n"
            "â€¢ Ð—Ð²ÐµÑ€Ð½ÑƒÑ‚Ð¸ÑÑ Ð´Ð¾ HR Ð´ÐµÐ¿Ð°Ñ€Ñ‚Ð°Ð¼ÐµÐ½Ñ‚Ñƒ\n"
            "â€¢ ÐŸÐ¾Ð´Ð¸Ð²Ð¸Ñ‚Ð¸ÑÑ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¸ ÑÐ¿ÐµÑ†Ñ–Ð°Ð»Ñ–ÑÑ‚Ñ–Ð²",
            reply_markup=create_main_menu_keyboard()
        )
```

4. **Add /start Handler for New Users**
```python
@router.message(Command("start"))
async def start_handler(message: Message):
    """Welcome new employee and show main menu"""
    
    user_name = message.from_user.first_name
    
    welcome_text = f"""
ðŸ‘‹ **Ð’Ñ–Ñ‚Ð°ÑŽ, {user_name}!**

Ð¯ Maya â€” HR Ð°ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚ Ð¢Ð” ÐÐ’. Ð”Ð¾Ð¿Ð¾Ð¼Ð¾Ð¶Ñƒ Ð²Ð°Ð¼ Ð·:

- ÐŸÐ¸Ñ‚Ð°Ð½Ð½ÑÐ¼Ð¸ Ð¿Ñ€Ð¾ Ð·Ð°Ñ€Ð¿Ð»Ð°Ñ‚Ñƒ Ñ‚Ð° Ð²Ñ–Ð´Ð¿ÑƒÑÑ‚ÐºÐ¸
- Ð¢ÐµÑ…Ð½Ñ–Ñ‡Ð½Ð¾ÑŽ Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ¾ÑŽ
- Ð†Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ”ÑŽ Ð´Ð»Ñ Ð½Ð¾Ð²Ð°Ñ‡ÐºÑ–Ð²
- ÐšÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð°Ð¼Ð¸ ÑÐ¿ÐµÑ†Ñ–Ð°Ð»Ñ–ÑÑ‚Ñ–Ð²
- Ð¢Ð° Ð±Ð°Ð³Ð°Ñ‚Ð¾ Ñ–Ð½ÑˆÐ¸Ð¼!

ÐŸÑ€Ð¾ÑÑ‚Ð¾ Ð½Ð°Ð¿Ð¸ÑˆÑ–Ñ‚ÑŒ ÑÐ²Ð¾Ñ” Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ Ð°Ð±Ð¾ Ð¾Ð±ÐµÑ€Ñ–Ñ‚ÑŒ Ñ€Ð¾Ð·Ð´Ñ–Ð» Ð· Ð¼ÐµÐ½ÑŽ ðŸ‘‡
"""
    
    await message.answer(
        welcome_text,
        reply_markup=create_main_menu_keyboard(),
        parse_mode="Markdown"
    )

@router.message(Command("help"))
async def help_handler(message: Message):
    """Show help information"""
    
    help_text = """
â„¹ï¸ **Ð¯Ðº ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Maya HR?**

**1. ÐÐ°Ð¿Ð¸ÑˆÑ–Ñ‚ÑŒ Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ**
ÐŸÑ€Ð¾ÑÑ‚Ð¾ Ð²Ð²ÐµÐ´Ñ–Ñ‚ÑŒ ÑÐ²Ð¾Ñ” Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ ÑƒÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ¾ÑŽ Ð¼Ð¾Ð²Ð¾ÑŽ.
ÐŸÑ€Ð¸ÐºÐ»Ð°Ð´: "ÐºÐ¾Ð»Ð¸ Ð²Ð¸Ð¿Ð»Ð°Ñ‡ÑƒÑŽÑ‚ÑŒ Ð·Ð°Ñ€Ð¿Ð»Ð°Ñ‚Ñƒ?"

**2. Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð¹Ñ‚Ðµ Ð¼ÐµÐ½ÑŽ**
ÐÐ°Ñ‚Ð¸ÑÐ½Ñ–Ñ‚ÑŒ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð´Ð»Ñ Ð½Ð°Ð²Ñ–Ð³Ð°Ñ†Ñ–Ñ— Ð¿Ð¾ Ñ€Ð¾Ð·Ð´Ñ–Ð»Ð°Ð¼.

**3. ÐšÐ¾Ñ€Ð¸ÑÐ½Ñ– ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸:**
/start - Ð“Ð¾Ð»Ð¾Ð²Ð½Ðµ Ð¼ÐµÐ½ÑŽ
/help - Ð¦Ñ Ð´Ð¾Ð²Ñ–Ð´ÐºÐ°
/contacts - ÐšÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¸ ÑÐ¿ÐµÑ†Ñ–Ð°Ð»Ñ–ÑÑ‚Ñ–Ð²

**ÐŸÑ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ°:** @hr_support
"""
    
    await message.answer(
        help_text,
        reply_markup=create_main_menu_keyboard(),
        parse_mode="Markdown"
    )

@router.message(Command("contacts"))
async def contacts_handler(message: Message):
    """Quick access to contacts"""
    
    await content_handler_direct(message, 'appendix_22')
```

5. **Add Settings to Config**

File: `app/config.py`
```python
class Settings(BaseSettings):
    # ... existing settings ...
    
    # HR Bot settings
    HR_BOT_ENABLED: bool = True
    HR_PRESET_THRESHOLD: int = 85  # Fuzzy matching threshold
    HR_RAG_TOP_K: int = 5  # Number of results for semantic search
    HR_MAX_MESSAGE_LENGTH: int = 3800  # Telegram limit buffer
    
    # API endpoints
    API_BASE_URL: str = "http://localhost:8000"  # Change for production
```

### Deployment Steps
```bash
# 1. Update dependencies (if needed)
pip install httpx  # For async HTTP requests

# 2. Test locally
python -m app.bot.main

# 3. Test in Telegram
# Send message to bot: "ÐºÐ¾Ð»Ð¸ Ð²Ð¸Ð¿Ð»Ð°Ñ‡ÑƒÑŽÑ‚ÑŒ Ð·Ð°Ñ€Ð¿Ð»Ð°Ñ‚Ñƒ?"

# 4. Deploy to Render
git add .
git commit -m "Add HR RAG integration to Telegram bot"
git push origin main

# Render will auto-deploy
```

### Testing Checklist

**Test Preset Answers:**
```
User: "ÐºÐ¾Ð»Ð¸ Ð²Ð¸Ð¿Ð»Ð°Ñ‡ÑƒÑŽÑ‚ÑŒ Ð·Ð°Ñ€Ð¿Ð»Ð°Ñ‚Ñƒ?"
Expected: Instant response with salary dates (< 0.1s)

User: "ÑÐºÑ–Ð»ÑŒÐºÐ¸ Ð´Ð½Ñ–Ð² Ð²Ñ–Ð´Ð¿ÑƒÑÑ‚ÐºÐ¸?"
Expected: Vacation info (18 days, etc.)
```

**Test RAG Search:**
```
User: "ÑÐº Ð²Ð¸Ñ€Ñ–ÑˆÐ¸Ñ‚Ð¸ ÐºÐ¾Ð½Ñ„Ð»Ñ–ÐºÑ‚ Ð· ÐºÐ¾Ð»ÐµÐ³Ð¾ÑŽ?"
Expected: Conflict resolution steps with sources

User: "Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ð· Ð²Ñ–Ð´Ð´Ð°Ð»ÐµÐ½ÐºÐ¾ÑŽ"
Expected: Remote desktop troubleshooting
```

**Test Menu Navigation:**
```
1. Send /start
2. Click "ðŸ’¼ Ð Ð¾Ð±Ð¾Ñ‡Ñ– Ð¿Ð¸Ñ‚Ð°Ð½Ð½Ñ"
3. Click "ðŸ–ï¸ Ð’Ñ–Ð´Ð¿ÑƒÑÑ‚ÐºÐ¸"
4. Should show vacation content
5. Click "ðŸ”™ ÐÐ°Ð·Ð°Ð´" - should go back to work menu
```

**Test Content Display:**
```
1. Request table (e.g., contacts)
2. Should format properly in monospace
3. Long content should split into multiple messages
```

### Acceptance Criteria
- âœ… /start shows welcome + main menu
- âœ… Text questions trigger RAG search
- âœ… Preset answers respond in < 0.1s
- âœ… Menu navigation works (6 categories)
- âœ… Content display handles text, tables, videos
- âœ… Long messages split properly
- âœ… Feedback buttons functional
- âœ… Error handling graceful
- âœ… Logs queries for analytics

### Files to Create/Modify
- `app/bot/handlers.py` (major update)
- `app/bot/keyboards.py` (new)
- `app/config.py` (add settings)

### Next Steps After This
- Phase 3: Video content integration
- Phase 4: Analytics dashboard
- Phase 5: Admin UI for preset management

### Notes
- Keep responses conversational and helpful
- Use emojis for visual appeal
- Always provide a way back to main menu
- Monitor response times (target: <2s for RAG)
- Track which questions get asked most