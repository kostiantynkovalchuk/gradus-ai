Universal API Token Monitor
Create comprehensive API token/quota monitoring system with proactive Telegram alerts:

üìã TASK: Build unified token monitoring service that checks all API services and alerts before expiration/limits

CREATE backend/services/api_token_monitor.py:
```python
import os
import requests
import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from anthropic import Anthropic
import openai

logger = logging.getLogger(__name__)

class APITokenMonitor:
    """
    Monitor all API tokens, quotas, and expiration dates
    Send proactive Telegram alerts before issues occur
    """
    
    def __init__(self):
        self.telegram_bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        self.telegram_chat_id = os.getenv('TELEGRAM_CHAT_ID')
        
        # Warning thresholds
        self.days_warning = 7  # Alert 7 days before expiration
        self.quota_warning_percent = 80  # Alert at 80% quota usage
        
    def check_all_services(self) -> Dict:
        """
        Check all API services
        Returns summary of all checks
        """
        
        results = {
            'timestamp': datetime.now().isoformat(),
            'services': {},
            'warnings': [],
            'errors': []
        }
        
        # Check each service
        services_to_check = [
            ('anthropic', self.check_anthropic_api),
            ('openai', self.check_openai_api),
            ('facebook', self.check_facebook_token),
            ('telegram', self.check_telegram_bot),
            ('elevenlabs', self.check_elevenlabs_quota),
            ('higgsfield', self.check_higgsfield_quota)
        ]
        
        for service_name, check_function in services_to_check:
            try:
                service_status = check_function()
                results['services'][service_name] = service_status
                
                # Collect warnings
                if service_status.get('warning'):
                    results['warnings'].append({
                        'service': service_name,
                        'message': service_status.get('warning_message')
                    })
                
                # Collect errors
                if service_status.get('status') == 'error':
                    results['errors'].append({
                        'service': service_name,
                        'message': service_status.get('error_message')
                    })
                    
            except Exception as e:
                logger.error(f"Error checking {service_name}: {e}")
                results['errors'].append({
                    'service': service_name,
                    'message': str(e)
                })
        
        # Send alerts if warnings or errors
        if results['warnings'] or results['errors']:
            self._send_alert_notification(results)
        
        return results
    
    def check_anthropic_api(self) -> Dict:
        """Check Claude API status and quota"""
        
        api_key = os.getenv('ANTHROPIC_API_KEY')
        
        if not api_key:
            return {
                'status': 'error',
                'error_message': 'No Anthropic API key configured'
            }
        
        try:
            # Anthropic doesn't have public quota API yet
            # But we can check if key is valid with minimal API call
            client = Anthropic(api_key=api_key)
            
            # Test with minimal request
            response = client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=10,
                messages=[{"role": "user", "content": "test"}]
            )
            
            return {
                'status': 'healthy',
                'service_name': 'Claude API (Anthropic)',
                'is_valid': True,
                'last_checked': datetime.now().isoformat(),
                'note': 'API key valid. Check usage at console.anthropic.com'
            }
            
        except Exception as e:
            error_msg = str(e)
            
            # Check for specific error types
            if 'invalid' in error_msg.lower() or 'authentication' in error_msg.lower():
                return {
                    'status': 'error',
                    'service_name': 'Claude API (Anthropic)',
                    'is_valid': False,
                    'error_message': 'API key invalid or expired',
                    'action_required': 'Update ANTHROPIC_API_KEY in Railway variables'
                }
            elif 'quota' in error_msg.lower() or 'limit' in error_msg.lower():
                return {
                    'status': 'warning',
                    'service_name': 'Claude API (Anthropic)',
                    'warning': True,
                    'warning_message': 'API quota may be exhausted',
                    'action_required': 'Check usage at console.anthropic.com'
                }
            else:
                return {
                    'status': 'error',
                    'service_name': 'Claude API (Anthropic)',
                    'error_message': error_msg
                }
    
    def check_openai_api(self) -> Dict:
        """Check OpenAI (DALL-E) API status and quota"""
        
        api_key = os.getenv('OPENAI_API_KEY')
        
        if not api_key:
            return {
                'status': 'error',
                'error_message': 'No OpenAI API key configured'
            }
        
        try:
            openai.api_key = api_key
            
            # Check account/organization details
            # Note: OpenAI removed direct quota endpoint, but we can test validity
            models = openai.models.list()
            
            # Check if we can access DALL-E models
            dalle_available = any('dall-e' in model.id for model in models.data)
            
            return {
                'status': 'healthy',
                'service_name': 'OpenAI API (DALL-E)',
                'is_valid': True,
                'dalle_available': dalle_available,
                'last_checked': datetime.now().isoformat(),
                'note': 'API key valid. Check usage at platform.openai.com/usage'
            }
            
        except Exception as e:
            error_msg = str(e)
            
            if 'invalid' in error_msg.lower() or 'authentication' in error_msg.lower():
                return {
                    'status': 'error',
                    'service_name': 'OpenAI API (DALL-E)',
                    'is_valid': False,
                    'error_message': 'API key invalid or expired',
                    'action_required': 'Update OPENAI_API_KEY in Railway variables'
                }
            elif 'quota' in error_msg.lower() or 'insufficient' in error_msg.lower():
                return {
                    'status': 'warning',
                    'service_name': 'OpenAI API (DALL-E)',
                    'warning': True,
                    'warning_message': 'API quota exhausted or payment issue',
                    'action_required': 'Add credits at platform.openai.com/billing'
                }
            else:
                return {
                    'status': 'error',
                    'service_name': 'OpenAI API (DALL-E)',
                    'error_message': error_msg
                }
    
    def check_facebook_token(self) -> Dict:
        """Check Facebook Page Access Token (already exists, enhance it)"""
        
        from services.facebook_token_manager import FacebookTokenManager
        
        try:
            token_manager = FacebookTokenManager()
            status = token_manager.check_token_expiration()
            
            if status.get('error'):
                return {
                    'status': 'error',
                    'service_name': 'Facebook Page Token',
                    'error_message': status['error']
                }
            
            days_remaining = status.get('days_remaining')
            
            if days_remaining is None:
                # Never expires
                return {
                    'status': 'healthy',
                    'service_name': 'Facebook Page Token',
                    'is_valid': True,
                    'expires': 'Never',
                    'last_checked': datetime.now().isoformat()
                }
            
            # Check if warning needed
            if days_remaining < self.days_warning:
                return {
                    'status': 'warning',
                    'service_name': 'Facebook Page Token',
                    'warning': True,
                    'warning_message': f'Token expires in {days_remaining} days',
                    'expires_at': status.get('expires_at'),
                    'action_required': 'Renew Facebook token soon'
                }
            else:
                return {
                    'status': 'healthy',
                    'service_name': 'Facebook Page Token',
                    'is_valid': True,
                    'days_remaining': days_remaining,
                    'expires_at': status.get('expires_at'),
                    'last_checked': datetime.now().isoformat()
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'service_name': 'Facebook Page Token',
                'error_message': str(e)
            }
    
    def check_telegram_bot(self) -> Dict:
        """Check Telegram Bot token validity"""
        
        try:
            url = f"https://api.telegram.org/bot{self.telegram_bot_token}/getMe"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                bot_info = response.json()
                return {
                    'status': 'healthy',
                    'service_name': 'Telegram Bot',
                    'is_valid': True,
                    'bot_username': bot_info['result'].get('username'),
                    'last_checked': datetime.now().isoformat()
                }
            else:
                return {
                    'status': 'error',
                    'service_name': 'Telegram Bot',
                    'is_valid': False,
                    'error_message': 'Invalid bot token',
                    'action_required': 'Update TELEGRAM_BOT_TOKEN in Railway variables'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'service_name': 'Telegram Bot',
                'error_message': str(e)
            }
    
    def check_elevenlabs_quota(self) -> Dict:
        """Check ElevenLabs API quota (if you have it)"""
        
        api_key = os.getenv('ELEVENLABS_API_KEY')
        
        if not api_key:
            return {
                'status': 'info',
                'service_name': 'ElevenLabs',
                'note': 'Not configured (optional service)'
            }
        
        try:
            url = "https://api.elevenlabs.io/v1/user/subscription"
            headers = {"xi-api-key": api_key}
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                character_count = data.get('character_count', 0)
                character_limit = data.get('character_limit', 0)
                
                if character_limit > 0:
                    usage_percent = (character_count / character_limit) * 100
                    
                    if usage_percent >= self.quota_warning_percent:
                        return {
                            'status': 'warning',
                            'service_name': 'ElevenLabs API',
                            'warning': True,
                            'warning_message': f'Quota at {usage_percent:.1f}% ({character_count}/{character_limit} chars)',
                            'action_required': 'Consider upgrading plan or reset date approaching'
                        }
                    else:
                        return {
                            'status': 'healthy',
                            'service_name': 'ElevenLabs API',
                            'is_valid': True,
                            'usage_percent': usage_percent,
                            'character_count': character_count,
                            'character_limit': character_limit,
                            'last_checked': datetime.now().isoformat()
                        }
                else:
                    return {
                        'status': 'healthy',
                        'service_name': 'ElevenLabs API',
                        'is_valid': True,
                        'note': 'Unlimited plan',
                        'last_checked': datetime.now().isoformat()
                    }
            else:
                return {
                    'status': 'error',
                    'service_name': 'ElevenLabs API',
                    'error_message': 'Invalid API key or quota check failed'
                }
                
        except Exception as e:
            return {
                'status': 'error',
                'service_name': 'ElevenLabs API',
                'error_message': str(e)
            }
    
    def check_higgsfield_quota(self) -> Dict:
        """Check Higgsfield API quota (if you have it)"""
        
        api_key = os.getenv('HIGGSFIELD_API_KEY')
        
        if not api_key:
            return {
                'status': 'info',
                'service_name': 'Higgsfield',
                'note': 'Not configured (optional service)'
            }
        
        try:
            # Check Higgsfield API documentation for quota endpoint
            # This is a placeholder - adjust based on actual API
            url = "https://api.higgsfield.ai/v1/account"
            headers = {"Authorization": f"Bearer {api_key}"}
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Adjust based on actual API response structure
                credits_used = data.get('credits_used', 0)
                credits_limit = data.get('credits_limit', 0)
                
                if credits_limit > 0:
                    usage_percent = (credits_used / credits_limit) * 100
                    
                    if usage_percent >= self.quota_warning_percent:
                        return {
                            'status': 'warning',
                            'service_name': 'Higgsfield API',
                            'warning': True,
                            'warning_message': f'Credits at {usage_percent:.1f}% ({credits_used}/{credits_limit})',
                            'action_required': 'Consider upgrading or wait for reset'
                        }
                
                return {
                    'status': 'healthy',
                    'service_name': 'Higgsfield API',
                    'is_valid': True,
                    'credits_used': credits_used,
                    'credits_limit': credits_limit,
                    'last_checked': datetime.now().isoformat()
                }
            else:
                return {
                    'status': 'error',
                    'service_name': 'Higgsfield API',
                    'error_message': 'Invalid API key or quota check failed'
                }
                
        except Exception as e:
            return {
                'status': 'info',
                'service_name': 'Higgsfield API',
                'note': f'Could not check quota: {str(e)}'
            }
    
    def _send_alert_notification(self, results: Dict):
        """Send Telegram alert about API issues"""
        
        message = "‚ö†Ô∏è <b>API SERVICE ALERTS</b>\n\n"
        
        # Warnings
        if results['warnings']:
            message += "üü° <b>WARNINGS:</b>\n"
            for warning in results['warnings']:
                service = warning['service']
                msg = warning['message']
                message += f"‚Ä¢ {service}: {msg}\n"
            message += "\n"
        
        # Errors
        if results['errors']:
            message += "üî¥ <b>ERRORS:</b>\n"
            for error in results['errors']:
                service = error['service']
                msg = error['message']
                message += f"‚Ä¢ {service}: {msg}\n"
            message += "\n"
        
        message += f"üïê Checked: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n"
        message += "\nüí° <i>Check Railway logs or dashboard for details</i>"
        
        try:
            url = f"https://api.telegram.org/bot{self.telegram_bot_token}/sendMessage"
            payload = {
                "chat_id": self.telegram_chat_id,
                "text": message,
                "parse_mode": "HTML"
            }
            
            requests.post(url, json=payload, timeout=10)
            logger.info("Alert notification sent to Telegram")
            
        except Exception as e:
            logger.error(f"Failed to send alert notification: {e}")
```

NOW UPDATE backend/services/scheduler.py to add token monitoring task:
```python
def check_all_api_tokens_task(self):
    """
    Check all API tokens and quotas
    Runs: Daily at 8:00 AM
    """
    logger.info("ü§ñ [SCHEDULER] Checking all API tokens...")
    
    try:
        from services.api_token_monitor import APITokenMonitor
        
        monitor = APITokenMonitor()
        results = monitor.check_all_services()
        
        # Log results
        healthy_count = sum(1 for s in results['services'].values() if s.get('status') == 'healthy')
        warning_count = len(results['warnings'])
        error_count = len(results['errors'])
        
        logger.info(f"Token check complete: {healthy_count} healthy, {warning_count} warnings, {error_count} errors")
        
        if error_count > 0:
            logger.error(f"API token errors detected: {results['errors']}")
        
    except Exception as e:
        logger.error(f"‚ùå [SCHEDULER] Token checking failed: {e}")
        import traceback
        logger.error(traceback.format_exc())

# In start() method, add:

self.scheduler.add_job(
    self.check_all_api_tokens_task,
    CronTrigger(hour=8, minute=0),  # Daily at 8:00 AM
    id='check_api_tokens',
    name='Check all API tokens and quotas',
    replace_existing=True
)
```

ALSO ADD endpoint to manually check tokens:
```python
# In backend/main.py

@app.get("/api/tokens/check")
async def check_all_tokens():
    """Manual check of all API tokens"""
    from services.api_token_monitor import APITokenMonitor
    
    monitor = APITokenMonitor()
    results = monitor.check_all_services()
    
    return results
```

This creates:
1. Daily automatic checking of ALL API services (8 AM)
2. Proactive Telegram alerts 7 days before expiration
3. Quota warnings at 80% usage
4. Manual check endpoint: /api/tokens/check
5. Extensible for future services

Please implement comprehensive API token monitoring!